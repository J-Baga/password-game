#include "passGuesser.hpp"

//if one thread finds the password, stop both threads
atomic<bool> isDone (false);
atomic<bool> genPasswords (false);

struct threadParameters{
    list<string> words;
    string password;
    int numWords;
};

/**
* Thread that instantiates a passGen object and gets every possible password permutation based
* on the list of words and the number words in the password. The thread will update the user 
* on the number of passwords it has currently gone through in increments of powers of 10.
* The time it will take to get to each increment will also increase.
* @param threadarg - The arguments for the threads.
*/
void *runSequential(void* threadarg){
    struct threadParameters *sequential;
    sequential = (struct threadParameters*) threadarg;
    passGen gen(sequential->words);
    gen.setIterationLength(sequential->numWords);
    unsigned long long int numIterations = 0;

    //Vectors used to help display the progress of the function
    vector<unsigned long long int> itrCheckPoints{1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000};
    int vectorElement = 0;
    vector<int> itrTimeStamps{500,1000,1500,2000,2500,3000,3500,4000,4500,5000};
    string sequentialPassword = gen.next();
    genPasswords.store(true);
    int updateCounter = 1;
    while(sequentialPassword != sequential->password){

        //check if a thread is done
        if (isDone.load()){
            break;
        }

        sequentialPassword = gen.next();
        //prints out the progress of the thread
        if(numIterations % itrCheckPoints[vectorElement] == 0){
            printf("Sequential Method Update %d: Iteration %d\n", updateCounter, numIterations);
            if(vectorElement <= (itrCheckPoints.size() - 1)){
                vectorElement++;
            }
            updateCounter++;
            Sleep(itrTimeStamps[vectorElement]);
        }
        numIterations++;        
    }
    
    if(sequentialPassword == sequential->password){
        //allows both threads to stop
        isDone.store(true);
        cout << "\nThe sequential thread has found the password: " <<  sequentialPassword << endl;
        if(numIterations != 0){
            cout << "It took " << numIterations << " iterations!\n" << endl;
        }
        else{
            cout << "It took 1 iteration!\n" << endl;
        }
    }
    return 0;
}

/**
* Thread that instantiates a passGen object and generates random passwords until
* it finds the correct one. Similar to the runSequential thread in terms of display
* and timing.
* @param threadarg - Arguments for the thread.
*/
void *runRandom(void *threadarg){
    struct threadParameters *random;
    random = (struct threadParameters*) threadarg;
    passGen gen(random->words);
    string randomPassword;
    gen.setIterationLength(random->numWords);
    unsigned long long int numIterations = 0;
    vector<unsigned long long int> itrCheckPoints{1,10,100,1000,10000,100000,1000000,10000000, 100000000, 1000000000};
    int vectorElement = 0;
    vector<int> itrTimeStamps{500,1000,1500,2000,2500,3000,3500,4000, 4500, 5000};
    // Waits for all the possible passwords to be generated by the runSequential thread before
    // it starts generating and checking random passwords.
    while(1){
        if(genPasswords){
            break;
        }
    }
    int updateCounter = 1;
    Sleep(500);
    while (randomPassword != random->password){
        if (isDone.load()){
            break;
        }
        
        randomPassword = gen.getRandomPassword(random->numWords);
        if(numIterations % itrCheckPoints[vectorElement] == 0){
            printf("Random Method Update %d: Password %d\n\n", updateCounter, numIterations);
            if(vectorElement <= (itrCheckPoints.size() - 1)){
                vectorElement++;
            }
            updateCounter++;
            Sleep(itrTimeStamps[vectorElement]);
        }
        numIterations++;
    }

    if (randomPassword == random->password){
        isDone.store(true);
        cout << "\nThe random thread has found the password: " << randomPassword << endl;
        if(numIterations == 1){
            cout << "It took 1 randomly generated password!\n" << endl;
        }
        else{
            cout << "It took " << numIterations << " randomly generated passwords!\n" << endl;
        }   
    }
    return 0;
}

/**
* Driver function that creates and runs the threads. Also instantiates a
* Password Generator object to obtain the random password to test the threads to.
* @param uniqueTokens - The number of unique tokens from the text file.
* @param length - Length of the password, in words.
*/
void passGuess::driver(list<string> uniqueTokens, int length) {
    passGen passGenerator(uniqueTokens);
    cout << "Enter the number of words to comprise a single password, between 1-5: ";
    cin >> length;

    //checks if the length of the words in the password is valid.
    while(length < 1 || length > 5) {
        cout << "Input is larger or lower than intended length range. Please enter a number between 1-5: ";
        cin >> length;
    }

    while(length > uniqueTokens.size()) {
        cout << "Length is greater than the amount of tokens. Please enter a number between 1-5: ";
        cin >> length;
    }

    passGenerator.setIterationLength(length);
    string password = passGenerator.getRandomPassword(length);
    cout << "The password to guess is: " << password << endl;
    cout << "-------------------------------------------------------------------------------------------------------------" << endl;
    struct threadParameters thread;
    thread.words = uniqueTokens;
    thread.password = password;
    thread.numWords = length;
    
    pthread_t sequentialThread;
    pthread_t randomThread;
    pthread_create(&sequentialThread, NULL, runSequential, &thread);
    pthread_create(&randomThread, NULL, runRandom, &thread);
    pthread_join(sequentialThread,NULL);
    pthread_join(randomThread,NULL);
    cout << "Test Complete..." << endl;
}
